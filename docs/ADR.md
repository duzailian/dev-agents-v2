# Architecture Decision Records (ADR)

> 文档版本：v2.0
>
> 记录AI驱动固件智能测试系统的关键架构决策
>
> 基于：Phase 1 架构设计与需求分析阶段成果

---

## ADR 概述

### 什么是 ADR

Architecture Decision Record (ADR) 是一种记录重大架构决策的轻量级方法。每个 ADR 记录了：
- **决策背景**：为什么需要做这个决策
- **决策方案**：最终选择的方案及其替代方案
- **预期后果**：决策的影响和后果
- **状态**：已决定 / 已废弃 / 被取代

### ADR 索引

| ID | 标题 | 状态 | 日期 |
|----|------|------|------|
| ADR-001 | 采用LangGraph作为唯一编排层 | 已决定 | 2026-01-27 |
| ADR-002 | 采用Tree-sitter进行C/C++代码解析 | 已决定 | 2026-01-27 |
| ADR-003 | 采用Qdrant作为向量数据库 | 已决定 | 2026-01-27 |
| ADR-004 | 四Agent协作架构设计 | 已决定 | 2026-01-27 |
| ADR-005 | 状态机驱动的迭代控制 | 已决定 | 2026-01-27 |
| ADR-006 | 混合存储架构（Qdrant + PostgreSQL） | 已决定 | 2026-01-27 |
| ADR-007 | 配置分层管理策略 | 已决定 | 2026-01-27 |

---

## ADR-001：采用LangGraph作为唯一编排层

### 状态

**已决定** | 2026-01-27

### 背景

项目初期曾考虑使用 CrewAI 作为二次编排层，但在架构评审中发现这会增加系统复杂性和状态同步问题。需要一个统一、简洁的编排方案。

### 决策

采用 **LangGraph** 作为系统唯一的编排框架，基于 State Graph 管理 Agent 的执行流程、状态流转和错误恢复。

### 方案对比

| 方案 | 优点 | 缺点 |
|------|------|------|
| **LangGraph（选择）** | 统一编排、状态清晰、社区活跃 | 需要学习曲线 |
| CrewAI + LangGraph | 高级Agent特性 | 双重编排、状态复杂 |
| 自研状态机 | 完全可控 | 开发成本高、维护困难 |

### 预期后果

- ✅ 状态管理统一、清晰
- ✅ 支持条件边和循环控制
- ✅ 与LangChain生态深度集成
- ⚠️ 需要团队熟悉LangGraph编程模型

### 相关文档

- [ARCHITECTURE_V2.md](ARCHITECTURE_V2.md)
- [STATE_MACHINE.md](STATE_MACHINE.md)

---

## ADR-002：采用Tree-sitter进行C/C++代码解析

### 状态

**已决定** | 2026-01-27

### 背景

需要对固件C/C++代码进行AST解析、函数提取、符号表构建等静态分析。需要一个高性能、支持增量解析的解析器。

### 决策

采用 **Tree-sitter** 作为核心代码解析引擎，配合 tree-sitter-c 和 tree-sitter-cpp 语言包。

### 方案对比

| 方案 | 优点 | 缺点 |
|------|------|------|
| **Tree-sitter（选择）** | 高性能、增量解析、C语法原生支持 | Rust绑定、部分API变更 |
| clang/llvm | 功能强大、工业级 | 重量级、学习曲线陡 |
| pycparser | 纯Python、轻量 | 功能有限、不支持C++ |

### 预期后果

- ✅ 高性能AST解析（<1秒/1000行）
- ✅ 支持增量解析
- ✅ 丰富的查询语言（TS Query）
- ⚠️ 新版API与旧版有差异，需要适配

### 相关文档

- [DETAILED_DESIGN_V2.md](DETAILED_DESIGN_V2.md) - 1.1 CodeAnalyzer

---

## ADR-003：采用Qdrant作为向量数据库

### 状态

**已决定** | 2026-01-27

### 背景

RAG系统需要向量数据库存储知识单元的语义向量，支持高效相似度检索。同时需要支持元数据过滤和混合查询。

### 决策

采用 **Qdrant** 作为向量数据库，**PostgreSQL** 作为关系数据库，形成混合存储架构。

### 方案对比

| 方案 | 优点 | 缺点 |
|------|------|------|
| **Qdrant（选择）** | Rust开发、高性能、gRPC支持 | 相对新、文档待完善 |
| Chroma | 轻量、易用 | 功能相对简单 |
| Pinecone | 云服务、托管 | 成本、数据隐私 |

### 预期后果

- ✅ 向量检索延迟<100ms
- ✅ 支持产品线标签过滤
- ✅ gRPC高性能接口
- ⚠️ 需要自行部署和维护

### 相关文档

- [KNOWLEDGE_SCHEMA.md](KNOWLEDGE_SCHEMA.md)

---

## ADR-004：四Agent协作架构设计

### 状态

**已决定** | 2026-01-27

### 背景

系统需要多个专业化的AI Agent协同工作，分别负责代码分析、测试执行、结果分析和知识管理。

### 决策

设计四个专业Agent，封装各自的底层引擎，通过LangGraph状态机进行协作：

1. **CodeAgent** - 代码分析与修改
2. **TestAgent** - 测试执行与控制
3. **AnalysisAgent** - 结果分析与决策
4. **KBAgent** - 知识库管理与检索

### Agent职责边界

| Agent | 核心引擎 | 主要职责 |
|-------|----------|----------|
| CodeAgent | CodeAnalyzer, CodeModifier | 代码解析、修改建议、补丁生成 |
| TestAgent | TestOrchestrator | 环境管理、测试执行、产物收集 |
| AnalysisAgent | ResultAnalyzer | 日志解析、失败归因、决策建议 |
| KBAgent | KnowledgeBase | 知识沉淀、RAG检索、经验复用 |

### 预期后果

- ✅ 职责清晰、边界明确
- ✅ 支持独立开发和测试
- ⚠️ 需要精心设计Agent间数据传递协议

### 相关文档

- [AGENT_DESIGN.md](AGENT_DESIGN.md)

---

## ADR-005：状态机驱动的迭代控制

### 状态

**已决定** | 2026-01-27

### 背景

系统的核心流程是"修改代码→启动测试→收集结果→决策下一步"的迭代循环。需要一个可控、可恢复、可解释的执行控制机制。

### 决策

采用状态机驱动的工作流控制，定义完整的顶层状态和状态转移规则。

### 状态定义

| 状态 | 含义 | 典型下一步 |
|------|------|------------|
| IDLE | 空闲/等待任务 | INIT |
| INIT | 初始化运行 | CODE_ANALYSIS |
| CODE_ANALYSIS | 分析问题与生成修改方案 | PATCH_GENERATION / ERROR_RECOVERY |
| PATCH_GENERATION | 生成补丁 | PATCH_APPLY / ERROR_RECOVERY |
| PATCH_APPLY | 应用补丁 | BUILD_SETUP |
| BUILD_SETUP / BUILD_RUN | 构建准备与执行 | TEST_SETUP / ERROR_RECOVERY |
| TEST_SETUP / TEST_RUN | 测试准备与执行 | RESULT_COLLECTION / ERROR_RECOVERY |
| RESULT_COLLECTION | 采集与结构化结果 | RESULT_ANALYSIS |
| RESULT_ANALYSIS | 结果分析与决策 | CONVERGENCE_CHECK |
| CONVERGENCE_CHECK | 收敛判断 | CODE_ANALYSIS / SUCCESS / FAILURE |
| ERROR_RECOVERY | 错误恢复 | 视情况返回 |

### 预期后果

- ✅ 执行流程可控、可观测
- ✅ 支持错误恢复和重试
- ✅ 便于调试和审计
- ⚠️ 状态较多，需要仔细设计状态转移逻辑

### 相关文档

- [STATE_MACHINE.md](STATE_MACHINE.md)

---

## ADR-006：混合存储架构（Qdrant + PostgreSQL）

### 状态

**已决定** | 2026-01-27

### 背景

知识库需要同时支持：
- 语义相似度检索（向量搜索）
- 结构化元数据查询（关系查询）
- 大对象存储（文档、日志）

### 决策

采用混合存储架构：

| 存储类型 | 技术选型 | 用途 |
|----------|----------|------|
| 向量存储 | Qdrant | 知识单元语义向量 |
| 关系存储 | PostgreSQL | 结构化元数据、标签 |
| 文件存储 | 本地文件系统 | 原始文档、日志、产物 |

### 数据模型

```
KnowledgeUnit
├── content: 文本内容（向量化存储于Qdrant）
├── metadata: 结构化元数据（存储于PostgreSQL）
├── relationships: 关联关系（PostgreSQL）
└── audit: 审计信息（PostgreSQL）
```

### 预期后果

- ✅ 充分发挥各存储类型优势
- ✅ 支持复杂查询和过滤
- ⚠️ 需要维护多存储一致性
- ⚠️ 部署和运维复杂度增加

### 相关文档

- [KNOWLEDGE_SCHEMA.md](KNOWLEDGE_SCHEMA.md)

---

## ADR-007：配置分层管理策略

### 状态

**已决定** | 2026-01-27

### 背景

系统需要在不同环境（开发、测试、生产）运行，需要清晰的配置优先级和覆盖机制。同时敏感配置需要安全管理。

### 决策

采用五层配置优先级结构（从低到高）：

| 优先级 | 配置来源 | 说明 |
|--------|----------|------|
| 5（最低） | 硬编码默认值 | 系统内置默认值 |
| 4 | 环境变量 | AFT_* 前缀的OS环境变量 |
| 3 | 配置文件 | YAML格式的环境特定配置 |
| 2 | 命令行参数 | CLI传递的运行时参数 |
| 1（最高） | 运行时API | 动态修改的配置覆盖 |

### 配置项分类

| 类别 | 示例 | 管理方式 |
|------|------|----------|
| 系统配置 | log_level, timeout | 配置文件 |
| 集成配置 | API密钥、URL | 环境变量 + 加密 |
| 环境配置 | QEMU路径、板卡IP | 环境特定配置 |
| Agent配置 | 模型参数、温度 | 配置文件 |

### 预期后果

- ✅ 配置灵活、可预测
- ✅ 支持多环境部署
- ✅ 敏感配置安全存储
- ⚠️ 需要文档化所有配置项

### 相关文档

- [CONFIG_MANAGEMENT.md](CONFIG_MANAGEMENT.md)

---

## ADR 创建指南

### 何时创建 ADR

当做出以下类型的架构决策时，应创建 ADR：
- 技术选型变更（如更换数据库、框架）
- 架构模式变化（如引入新层、新模式）
- 设计权衡（选择A方案而非B方案）
- 重大重构决策

### ADR 模板

```markdown
# ADR-[编号]：决策标题

## 状态

**已决定/已废弃/被取代** | YYYY-MM-DD

## 背景

[描述做出决策的背景和问题]

## 决策

[描述最终选择的方案]

## 方案对比

| 方案 | 优点 | 缺点 |
|------|------|------|
| 方案A | ... | ... |
| 方案B（选择） | ... | ... |

## 预期后果

- ✅ 正面影响
- ⚠️ 需要注意的问题

## 相关文档

- [链接到相关文档]
```

### ADR 维护规则

1. **创建**：新ADR使用下一个可用编号
2. **更新**：决策变更时更新ADR状态
3. **废弃**：决策废弃时标记状态并说明原因
4. **索引**：保持ADR索引表更新

---

## 变更历史

| 日期 | 变更内容 | 变更人 |
|------|----------|--------|
| 2026-01-27 | 初始版本，创建7个核心ADR | Sisyphus |
| 2026-01-31 | 统一版本号为v2.0，补充ADR-007 | Sisyphus |
